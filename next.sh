#!/bin/bash

# Check if an app name was provided as an argument
if [ -z "$1" ]; then
  echo "Error: Please provide a name for your Next.js app."
  echo "Usage: ./setup/next.sh <app-name>"
  exit 1
fi

APP_NAME=$1

# Convert the app name to title case (capitalize first letter of each word)
APP_TITLE=$(echo "$APP_NAME" | awk '{ for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)) } 1')

# Step 1: Remove existing directory if it exists
echo "Cleaning up any existing directory..."
rm -rf "$APP_NAME"

# Step 2: Initialize a new Next.js app with pnpm, automatically including Tailwind CSS
echo "Initializing a new Next.js app named $APP_NAME..."
npx create-next-app@latest "$APP_NAME" --ts --tailwind --eslint --app --src-dir --use-pnpm --turbopack false --yes

# Step 3: Move into the project directory
cd "$APP_NAME" || { echo "Failed to create or access the app directory"; exit 1; }

# Step 4: Install required dependencies
echo "Installing NextThemes, lucide-react, clsx, tailwind-merge, and other dependencies..."
pnpm install next-themes lucide-react clsx tailwind-merge

# Step 5: Initialize ShadCN with slate as the base color
echo "Initializing ShadCN..."
echo "slate" | pnpm dlx shadcn@latest init

# Step 6: Create utils.ts file
echo "Creating utils.ts file..."
mkdir -p src/lib
cat > src/lib/utils.ts <<EOL
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
EOL

# Step 7: Install all ShadCN components
echo "Installing all ShadCN components..."
pnpm dlx shadcn@latest add accordion alert alert-dialog aspect-ratio avatar badge breadcrumb button calendar card carousel chart checkbox collapsible command context-menu dialog drawer dropdown-menu form hover-card input input-otp label menubar navigation-menu pagination popover progress radio-group resizable scroll-area select separator sheet sidebar skeleton slider sonner switch table tabs textarea toggle toggle-group tooltip --yes

# Step 8: Update layout.tsx with provided content
echo "Updating layout.tsx..."
cat > src/app/layout.tsx <<EOL
import type { Metadata } from "next";
import { Bitter } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";
import { GlobalNav } from "@/components/global-nav";

const bitter = Bitter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "$APP_TITLE",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={\`\${bitter.className} antialiased\`} suppressHydrationWarning>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
          <GlobalNav />
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}
EOL

# Step 9: Update page.tsx with provided content
echo "Updating page.tsx..."
cat > src/app/page.tsx <<EOL
import { Button } from "@/components/ui/button"

export default function Home() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <Button className="cursor-pointer">Hello</Button>
    </div>
  );
}
EOL

# Step 10: Create theme-provider.tsx component
echo "Creating theme-provider.tsx..."
mkdir -p src/components
cat > src/components/theme-provider.tsx <<EOL
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return (
    <NextThemesProvider {...props} suppressHydrationWarning>
      {children}
    </NextThemesProvider>
  )
}
EOL

# Step 11: Create global-nav.tsx component with dynamic title
echo "Creating global-nav.tsx..."
cat > src/components/global-nav.tsx <<EOL
import Link from "next/link"
import { ThemeToggle } from "@/components/theme-toggle"

export function GlobalNav() {
  return (
    <nav className="fixed top-0 left-0 right-0 flex justify-between items-center p-4 bg-zinc-300 dark:bg-black">
      <Link href="/" className="text-2xl font-bold hover:opacity-80 transition-opacity cursor-pointer">
        $APP_TITLE
      </Link>
      <ThemeToggle />
    </nav>
  )
}
EOL

# Step 12: Create theme-toggle.tsx component with sun and moon icons
echo "Creating theme-toggle.tsx..."
cat > src/components/theme-toggle.tsx <<EOL
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"

export function ThemeToggle() {
  const [mounted, setMounted] = React.useState(false)

  // useEffect only runs on the client, so now we can safely show the UI
  React.useEffect(() => {
    setMounted(true)
  }, [])

  const { theme, setTheme } = useTheme()

  // Render the same button shape regardless of mounted state to avoid hydration mismatch
  return (
    <Button
      variant="outline"
      size="icon"
      className="cursor-pointer"
      onClick={() => mounted && setTheme(theme === "light" ? "dark" : "light")}
      suppressHydrationWarning
    >
      {mounted ? (
        <>
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
        </>
      ) : (
        <div className="h-[1.2rem] w-[1.2rem]" />
      )}
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}
EOL

# Step 13: Create conventions.md file
echo "Creating conventions.md..."
cat > conventions.md <<EOL
# Folder Structure:
root
├── public
│   └── images
├── src
│   └── app
│       ├── favicon.ico
│       ├── globals.css
│       ├── layout.tsx
│       ├── page.tsx
│       └── components
│           ├── ui
│           ├── hooks
│           └── lib
├── .env
├── .env.local
├── next.config.mjs
├── package.json
├── README.md
├── tailwind.config.ts
└── tsconfig.json

# Conventions:
- Assume next-themes is being used and is already implemented
- Assume all ShadCN components are installed and available to use
- Use ShadCN components and lucide-react icons wherever possible
- All components should look good in dark or light mode using Tailwind's 'dark' modifier
- Add "use client" to the top of files which rely on React to maintain state or have interactivity or use hooks.
EOL

# Step 14: Create .aider.conf.yml file
echo "Creating .aider.conf.yml..."
cat > .aider.conf.yml <<EOL
read: ["conventions.md", "package.json"]
EOL

# Return to original directory
cd ..

# Step 15: Create .clinerules file
echo "Creating .clinerules file..."
cd "$APP_NAME"
cat > .clinerules <<EOL
## General Guidelines
- prefer pnpm for installs
- focus on code changes, optimization and new code generation
- Focus on meaningful code changes specific to user requests. 

## Next JS App Guidelines
- Follow clean coding principles
- Code should be type safe
- Use professional and clear comments where helpful
- use shadcn components wherever possible
- prefer lucide react icons
- Assume next-themes is implemented and dark mode is default
- Use tailwind classes
- Prefer tailwind colors over custom css colors
- Assume app uses src dir 
- Assume app uses app router
- Assume all components must look good in either dark or light mode
- Page routes should remain server components
- Client-side functionality should be implemented in client components within feature folders
- Feature UI components should be client components
- State management and interactivity should be handled in client components

## Next JS App Architecture Guidelines
- Prefer feature module pattern: /src/app/features/[feature-name]
- Use Repository, Service, Hooks pattern where appropriate
- Repositories and Services should implement interfaces
- Use Zod for type inference and validation where appropriate
- Assume mock data should be generated in sufficient quantity to thoroughly test and review the feature requested. A mock data repository is the suggested approach.

## Import Guidelines
- Use @/ alias for all imports from the src directory
- Example: import { Button } from "@/components/ui/button" (see below for file content)
- The @/ alias is properly configured in tsconfig.json
- Avoid relative paths for imports from src directory
- Keep imports organized and grouped by type (external, internal, etc.)

FEATURE FOLDER EXAMPLE
src/app/features/[feature-name]/
├── components/
├── hooks/
├── repository/
├── service/
├── types/
└── utils/
EOL

# Step 16: Run the development server
echo "Starting the development server..."
pnpm run dev
